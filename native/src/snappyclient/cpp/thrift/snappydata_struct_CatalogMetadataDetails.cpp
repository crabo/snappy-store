/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "snappydata_struct_CatalogMetadataDetails.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace io { namespace snappydata { namespace thrift {


CatalogMetadataDetails::~CatalogMetadataDetails() noexcept {
}


void CatalogMetadataDetails::__set_names(const std::vector<std::string> & val) {
  this->names = val;
__isset.names = true;
}

void CatalogMetadataDetails::__set_properties(const std::vector<std::map<std::string, std::string> > & val) {
  this->properties = val;
__isset.properties = true;
}

void CatalogMetadataDetails::__set_newProperties(const std::vector<std::map<std::string, std::string> > & val) {
  this->newProperties = val;
__isset.newProperties = true;
}

void CatalogMetadataDetails::__set_catalogSchemaVersion(const int64_t val) {
  this->catalogSchemaVersion = val;
__isset.catalogSchemaVersion = true;
}

void CatalogMetadataDetails::__set_exists(const bool val) {
  this->exists = val;
__isset.exists = true;
}

void CatalogMetadataDetails::__set_otherFlags(const std::vector<int32_t> & val) {
  this->otherFlags = val;
__isset.otherFlags = true;
}

void CatalogMetadataDetails::__set_catalogDatabase(const CatalogSchemaObject& val) {
  this->catalogDatabase = val;
__isset.catalogDatabase = true;
}

void CatalogMetadataDetails::__set_catalogTable(const CatalogTableObject& val) {
  this->catalogTable = val;
__isset.catalogTable = true;
}

void CatalogMetadataDetails::__set_catalogFunction(const CatalogFunctionObject& val) {
  this->catalogFunction = val;
__isset.catalogFunction = true;
}

void CatalogMetadataDetails::__set_catalogPartitions(const std::vector<CatalogPartitionObject> & val) {
  this->catalogPartitions = val;
__isset.catalogPartitions = true;
}

void CatalogMetadataDetails::__set_catalogStats(const CatalogStats& val) {
  this->catalogStats = val;
__isset.catalogStats = true;
}

void CatalogMetadataDetails::__set_newSchema(const std::string& val) {
  this->newSchema = val;
__isset.newSchema = true;
}

uint32_t CatalogMetadataDetails::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size458;
            ::apache::thrift::protocol::TType _etype461;
            xfer += iprot->readListBegin(_etype461, _size458);
            this->names.resize(_size458);
            uint32_t _i462;
            for (_i462 = 0; _i462 < _size458; ++_i462)
            {
              xfer += iprot->readString(this->names[_i462]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->properties.clear();
            uint32_t _size463;
            ::apache::thrift::protocol::TType _etype466;
            xfer += iprot->readListBegin(_etype466, _size463);
            this->properties.resize(_size463);
            uint32_t _i467;
            for (_i467 = 0; _i467 < _size463; ++_i467)
            {
              {
                this->properties[_i467].clear();
                uint32_t _size468;
                ::apache::thrift::protocol::TType _ktype469;
                ::apache::thrift::protocol::TType _vtype470;
                xfer += iprot->readMapBegin(_ktype469, _vtype470, _size468);
                uint32_t _i472;
                for (_i472 = 0; _i472 < _size468; ++_i472)
                {
                  std::string _key473;
                  xfer += iprot->readString(_key473);
                  std::string& _val474 = this->properties[_i467][_key473];
                  xfer += iprot->readString(_val474);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->newProperties.clear();
            uint32_t _size475;
            ::apache::thrift::protocol::TType _etype478;
            xfer += iprot->readListBegin(_etype478, _size475);
            this->newProperties.resize(_size475);
            uint32_t _i479;
            for (_i479 = 0; _i479 < _size475; ++_i479)
            {
              {
                this->newProperties[_i479].clear();
                uint32_t _size480;
                ::apache::thrift::protocol::TType _ktype481;
                ::apache::thrift::protocol::TType _vtype482;
                xfer += iprot->readMapBegin(_ktype481, _vtype482, _size480);
                uint32_t _i484;
                for (_i484 = 0; _i484 < _size480; ++_i484)
                {
                  std::string _key485;
                  xfer += iprot->readString(_key485);
                  std::string& _val486 = this->newProperties[_i479][_key485];
                  xfer += iprot->readString(_val486);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.newProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->catalogSchemaVersion);
          this->__isset.catalogSchemaVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->exists);
          this->__isset.exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->otherFlags.clear();
            uint32_t _size487;
            ::apache::thrift::protocol::TType _etype490;
            xfer += iprot->readListBegin(_etype490, _size487);
            this->otherFlags.resize(_size487);
            uint32_t _i491;
            for (_i491 = 0; _i491 < _size487; ++_i491)
            {
              xfer += iprot->readI32(this->otherFlags[_i491]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.otherFlags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalogDatabase.read(iprot);
          this->__isset.catalogDatabase = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalogTable.read(iprot);
          this->__isset.catalogTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalogFunction.read(iprot);
          this->__isset.catalogFunction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->catalogPartitions.clear();
            uint32_t _size492;
            ::apache::thrift::protocol::TType _etype495;
            xfer += iprot->readListBegin(_etype495, _size492);
            this->catalogPartitions.resize(_size492);
            uint32_t _i496;
            for (_i496 = 0; _i496 < _size492; ++_i496)
            {
              xfer += this->catalogPartitions[_i496].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.catalogPartitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalogStats.read(iprot);
          this->__isset.catalogStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->newSchema);
          this->__isset.newSchema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CatalogMetadataDetails::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CatalogMetadataDetails");

  if (this->__isset.names) {
    xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->names.size()));
      std::vector<std::string> ::const_iterator _iter497;
      for (_iter497 = this->names.begin(); _iter497 != this->names.end(); ++_iter497)
      {
        xfer += oprot->writeString((*_iter497));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.properties) {
    xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->properties.size()));
      std::vector<std::map<std::string, std::string> > ::const_iterator _iter498;
      for (_iter498 = this->properties.begin(); _iter498 != this->properties.end(); ++_iter498)
      {
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter498).size()));
          std::map<std::string, std::string> ::const_iterator _iter499;
          for (_iter499 = (*_iter498).begin(); _iter499 != (*_iter498).end(); ++_iter499)
          {
            xfer += oprot->writeString(_iter499->first);
            xfer += oprot->writeString(_iter499->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.newProperties) {
    xfer += oprot->writeFieldBegin("newProperties", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->newProperties.size()));
      std::vector<std::map<std::string, std::string> > ::const_iterator _iter500;
      for (_iter500 = this->newProperties.begin(); _iter500 != this->newProperties.end(); ++_iter500)
      {
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter500).size()));
          std::map<std::string, std::string> ::const_iterator _iter501;
          for (_iter501 = (*_iter500).begin(); _iter501 != (*_iter500).end(); ++_iter501)
          {
            xfer += oprot->writeString(_iter501->first);
            xfer += oprot->writeString(_iter501->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalogSchemaVersion) {
    xfer += oprot->writeFieldBegin("catalogSchemaVersion", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->catalogSchemaVersion);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exists) {
    xfer += oprot->writeFieldBegin("exists", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->exists);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.otherFlags) {
    xfer += oprot->writeFieldBegin("otherFlags", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->otherFlags.size()));
      std::vector<int32_t> ::const_iterator _iter502;
      for (_iter502 = this->otherFlags.begin(); _iter502 != this->otherFlags.end(); ++_iter502)
      {
        xfer += oprot->writeI32((*_iter502));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalogDatabase) {
    xfer += oprot->writeFieldBegin("catalogDatabase", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->catalogDatabase.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalogTable) {
    xfer += oprot->writeFieldBegin("catalogTable", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->catalogTable.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalogFunction) {
    xfer += oprot->writeFieldBegin("catalogFunction", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->catalogFunction.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalogPartitions) {
    xfer += oprot->writeFieldBegin("catalogPartitions", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->catalogPartitions.size()));
      std::vector<CatalogPartitionObject> ::const_iterator _iter503;
      for (_iter503 = this->catalogPartitions.begin(); _iter503 != this->catalogPartitions.end(); ++_iter503)
      {
        xfer += (*_iter503).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalogStats) {
    xfer += oprot->writeFieldBegin("catalogStats", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->catalogStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.newSchema) {
    xfer += oprot->writeFieldBegin("newSchema", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->newSchema);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CatalogMetadataDetails &a, CatalogMetadataDetails &b) {
  using ::std::swap;
  swap(a.names, b.names);
  swap(a.properties, b.properties);
  swap(a.newProperties, b.newProperties);
  swap(a.catalogSchemaVersion, b.catalogSchemaVersion);
  swap(a.exists, b.exists);
  swap(a.otherFlags, b.otherFlags);
  swap(a.catalogDatabase, b.catalogDatabase);
  swap(a.catalogTable, b.catalogTable);
  swap(a.catalogFunction, b.catalogFunction);
  swap(a.catalogPartitions, b.catalogPartitions);
  swap(a.catalogStats, b.catalogStats);
  swap(a.newSchema, b.newSchema);
  swap(a.__isset, b.__isset);
}

CatalogMetadataDetails::CatalogMetadataDetails(const CatalogMetadataDetails& other504) {
  names = other504.names;
  properties = other504.properties;
  newProperties = other504.newProperties;
  catalogSchemaVersion = other504.catalogSchemaVersion;
  exists = other504.exists;
  otherFlags = other504.otherFlags;
  catalogDatabase = other504.catalogDatabase;
  catalogTable = other504.catalogTable;
  catalogFunction = other504.catalogFunction;
  catalogPartitions = other504.catalogPartitions;
  catalogStats = other504.catalogStats;
  newSchema = other504.newSchema;
  __isset = other504.__isset;
}
CatalogMetadataDetails::CatalogMetadataDetails( CatalogMetadataDetails&& other505) noexcept {
  names = std::move(other505.names);
  properties = std::move(other505.properties);
  newProperties = std::move(other505.newProperties);
  catalogSchemaVersion = std::move(other505.catalogSchemaVersion);
  exists = std::move(other505.exists);
  otherFlags = std::move(other505.otherFlags);
  catalogDatabase = std::move(other505.catalogDatabase);
  catalogTable = std::move(other505.catalogTable);
  catalogFunction = std::move(other505.catalogFunction);
  catalogPartitions = std::move(other505.catalogPartitions);
  catalogStats = std::move(other505.catalogStats);
  newSchema = std::move(other505.newSchema);
  __isset = std::move(other505.__isset);
}
CatalogMetadataDetails& CatalogMetadataDetails::operator=(const CatalogMetadataDetails& other506) {
  names = other506.names;
  properties = other506.properties;
  newProperties = other506.newProperties;
  catalogSchemaVersion = other506.catalogSchemaVersion;
  exists = other506.exists;
  otherFlags = other506.otherFlags;
  catalogDatabase = other506.catalogDatabase;
  catalogTable = other506.catalogTable;
  catalogFunction = other506.catalogFunction;
  catalogPartitions = other506.catalogPartitions;
  catalogStats = other506.catalogStats;
  newSchema = other506.newSchema;
  __isset = other506.__isset;
  return *this;
}
CatalogMetadataDetails& CatalogMetadataDetails::operator=(CatalogMetadataDetails&& other507) noexcept {
  names = std::move(other507.names);
  properties = std::move(other507.properties);
  newProperties = std::move(other507.newProperties);
  catalogSchemaVersion = std::move(other507.catalogSchemaVersion);
  exists = std::move(other507.exists);
  otherFlags = std::move(other507.otherFlags);
  catalogDatabase = std::move(other507.catalogDatabase);
  catalogTable = std::move(other507.catalogTable);
  catalogFunction = std::move(other507.catalogFunction);
  catalogPartitions = std::move(other507.catalogPartitions);
  catalogStats = std::move(other507.catalogStats);
  newSchema = std::move(other507.newSchema);
  __isset = std::move(other507.__isset);
  return *this;
}
void CatalogMetadataDetails::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CatalogMetadataDetails(";
  out << "names="; (__isset.names ? (out << to_string(names)) : (out << "<null>"));
  out << ", " << "properties="; (__isset.properties ? (out << to_string(properties)) : (out << "<null>"));
  out << ", " << "newProperties="; (__isset.newProperties ? (out << to_string(newProperties)) : (out << "<null>"));
  out << ", " << "catalogSchemaVersion="; (__isset.catalogSchemaVersion ? (out << to_string(catalogSchemaVersion)) : (out << "<null>"));
  out << ", " << "exists="; (__isset.exists ? (out << to_string(exists)) : (out << "<null>"));
  out << ", " << "otherFlags="; (__isset.otherFlags ? (out << to_string(otherFlags)) : (out << "<null>"));
  out << ", " << "catalogDatabase="; (__isset.catalogDatabase ? (out << to_string(catalogDatabase)) : (out << "<null>"));
  out << ", " << "catalogTable="; (__isset.catalogTable ? (out << to_string(catalogTable)) : (out << "<null>"));
  out << ", " << "catalogFunction="; (__isset.catalogFunction ? (out << to_string(catalogFunction)) : (out << "<null>"));
  out << ", " << "catalogPartitions="; (__isset.catalogPartitions ? (out << to_string(catalogPartitions)) : (out << "<null>"));
  out << ", " << "catalogStats="; (__isset.catalogStats ? (out << to_string(catalogStats)) : (out << "<null>"));
  out << ", " << "newSchema="; (__isset.newSchema ? (out << to_string(newSchema)) : (out << "<null>"));
  out << ")";
}

}}} // namespace
