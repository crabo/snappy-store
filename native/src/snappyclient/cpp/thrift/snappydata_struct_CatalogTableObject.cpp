/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "snappydata_struct_CatalogTableObject.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace io { namespace snappydata { namespace thrift {


CatalogTableObject::~CatalogTableObject() noexcept {
}


void CatalogTableObject::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void CatalogTableObject::__set_databaseName(const std::string& val) {
  this->databaseName = val;
__isset.databaseName = true;
}

void CatalogTableObject::__set_tableType(const std::string& val) {
  this->tableType = val;
}

void CatalogTableObject::__set_storage(const CatalogStorage& val) {
  this->storage = val;
}

void CatalogTableObject::__set_tableSchema(const std::string& val) {
  this->tableSchema = val;
}

void CatalogTableObject::__set_provider(const std::string& val) {
  this->provider = val;
__isset.provider = true;
}

void CatalogTableObject::__set_partitionColumns(const std::vector<std::string> & val) {
  this->partitionColumns = val;
}

void CatalogTableObject::__set_indexColumns(const std::vector<std::string> & val) {
  this->indexColumns = val;
}

void CatalogTableObject::__set_primaryKeyColumns(const std::vector<std::string> & val) {
  this->primaryKeyColumns = val;
}

void CatalogTableObject::__set_numBuckets(const int32_t val) {
  this->numBuckets = val;
__isset.numBuckets = true;
}

void CatalogTableObject::__set_redundancy(const int32_t val) {
  this->redundancy = val;
__isset.redundancy = true;
}

void CatalogTableObject::__set_bucketOwners(const std::vector<BucketOwners> & val) {
  this->bucketOwners = val;
}

void CatalogTableObject::__set_bucketColumns(const std::vector<std::string> & val) {
  this->bucketColumns = val;
}

void CatalogTableObject::__set_sortColumns(const std::vector<std::string> & val) {
  this->sortColumns = val;
}

void CatalogTableObject::__set_owner(const std::string& val) {
  this->owner = val;
}

void CatalogTableObject::__set_createTime(const int64_t val) {
  this->createTime = val;
}

void CatalogTableObject::__set_lastAccessTime(const int64_t val) {
  this->lastAccessTime = val;
}

void CatalogTableObject::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
}

void CatalogTableObject::__set_stats(const CatalogStats& val) {
  this->stats = val;
__isset.stats = true;
}

void CatalogTableObject::__set_viewOriginalText(const std::string& val) {
  this->viewOriginalText = val;
__isset.viewOriginalText = true;
}

void CatalogTableObject::__set_viewText(const std::string& val) {
  this->viewText = val;
__isset.viewText = true;
}

void CatalogTableObject::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}

void CatalogTableObject::__set_unsupportedFeatures(const std::vector<std::string> & val) {
  this->unsupportedFeatures = val;
}

void CatalogTableObject::__set_tracksPartitionsInCatalog(const bool val) {
  this->tracksPartitionsInCatalog = val;
}

void CatalogTableObject::__set_schemaPreservesCase(const bool val) {
  this->schemaPreservesCase = val;
}

void CatalogTableObject::__set_ignoredProperties(const std::map<std::string, std::string> & val) {
  this->ignoredProperties = val;
__isset.ignoredProperties = true;
}

uint32_t CatalogTableObject::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tableName = false;
  bool isset_tableType = false;
  bool isset_storage = false;
  bool isset_tableSchema = false;
  bool isset_partitionColumns = false;
  bool isset_indexColumns = false;
  bool isset_primaryKeyColumns = false;
  bool isset_bucketOwners = false;
  bool isset_bucketColumns = false;
  bool isset_sortColumns = false;
  bool isset_owner = false;
  bool isset_createTime = false;
  bool isset_lastAccessTime = false;
  bool isset_properties = false;
  bool isset_unsupportedFeatures = false;
  bool isset_tracksPartitionsInCatalog = false;
  bool isset_schemaPreservesCase = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->databaseName);
          this->__isset.databaseName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableType);
          isset_tableType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->storage.read(iprot);
          isset_storage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableSchema);
          isset_tableSchema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->provider);
          this->__isset.provider = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionColumns.clear();
            uint32_t _size354;
            ::apache::thrift::protocol::TType _etype357;
            xfer += iprot->readListBegin(_etype357, _size354);
            this->partitionColumns.resize(_size354);
            uint32_t _i358;
            for (_i358 = 0; _i358 < _size354; ++_i358)
            {
              xfer += iprot->readString(this->partitionColumns[_i358]);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitionColumns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->indexColumns.clear();
            uint32_t _size359;
            ::apache::thrift::protocol::TType _etype362;
            xfer += iprot->readListBegin(_etype362, _size359);
            this->indexColumns.resize(_size359);
            uint32_t _i363;
            for (_i363 = 0; _i363 < _size359; ++_i363)
            {
              xfer += iprot->readString(this->indexColumns[_i363]);
            }
            xfer += iprot->readListEnd();
          }
          isset_indexColumns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->primaryKeyColumns.clear();
            uint32_t _size364;
            ::apache::thrift::protocol::TType _etype367;
            xfer += iprot->readListBegin(_etype367, _size364);
            this->primaryKeyColumns.resize(_size364);
            uint32_t _i368;
            for (_i368 = 0; _i368 < _size364; ++_i368)
            {
              xfer += iprot->readString(this->primaryKeyColumns[_i368]);
            }
            xfer += iprot->readListEnd();
          }
          isset_primaryKeyColumns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numBuckets);
          this->__isset.numBuckets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->redundancy);
          this->__isset.redundancy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bucketOwners.clear();
            uint32_t _size369;
            ::apache::thrift::protocol::TType _etype372;
            xfer += iprot->readListBegin(_etype372, _size369);
            this->bucketOwners.resize(_size369);
            uint32_t _i373;
            for (_i373 = 0; _i373 < _size369; ++_i373)
            {
              xfer += this->bucketOwners[_i373].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_bucketOwners = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bucketColumns.clear();
            uint32_t _size374;
            ::apache::thrift::protocol::TType _etype377;
            xfer += iprot->readListBegin(_etype377, _size374);
            this->bucketColumns.resize(_size374);
            uint32_t _i378;
            for (_i378 = 0; _i378 < _size374; ++_i378)
            {
              xfer += iprot->readString(this->bucketColumns[_i378]);
            }
            xfer += iprot->readListEnd();
          }
          isset_bucketColumns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sortColumns.clear();
            uint32_t _size379;
            ::apache::thrift::protocol::TType _etype382;
            xfer += iprot->readListBegin(_etype382, _size379);
            this->sortColumns.resize(_size379);
            uint32_t _i383;
            for (_i383 = 0; _i383 < _size379; ++_i383)
            {
              xfer += iprot->readString(this->sortColumns[_i383]);
            }
            xfer += iprot->readListEnd();
          }
          isset_sortColumns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner);
          isset_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTime);
          isset_createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastAccessTime);
          isset_lastAccessTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size384;
            ::apache::thrift::protocol::TType _ktype385;
            ::apache::thrift::protocol::TType _vtype386;
            xfer += iprot->readMapBegin(_ktype385, _vtype386, _size384);
            uint32_t _i388;
            for (_i388 = 0; _i388 < _size384; ++_i388)
            {
              std::string _key389;
              xfer += iprot->readString(_key389);
              std::string& _val390 = this->properties[_key389];
              xfer += iprot->readString(_val390);
            }
            xfer += iprot->readMapEnd();
          }
          isset_properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stats.read(iprot);
          this->__isset.stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewOriginalText);
          this->__isset.viewOriginalText = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewText);
          this->__isset.viewText = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->unsupportedFeatures.clear();
            uint32_t _size391;
            ::apache::thrift::protocol::TType _etype394;
            xfer += iprot->readListBegin(_etype394, _size391);
            this->unsupportedFeatures.resize(_size391);
            uint32_t _i395;
            for (_i395 = 0; _i395 < _size391; ++_i395)
            {
              xfer += iprot->readString(this->unsupportedFeatures[_i395]);
            }
            xfer += iprot->readListEnd();
          }
          isset_unsupportedFeatures = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->tracksPartitionsInCatalog);
          isset_tracksPartitionsInCatalog = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->schemaPreservesCase);
          isset_schemaPreservesCase = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->ignoredProperties.clear();
            uint32_t _size396;
            ::apache::thrift::protocol::TType _ktype397;
            ::apache::thrift::protocol::TType _vtype398;
            xfer += iprot->readMapBegin(_ktype397, _vtype398, _size396);
            uint32_t _i400;
            for (_i400 = 0; _i400 < _size396; ++_i400)
            {
              std::string _key401;
              xfer += iprot->readString(_key401);
              std::string& _val402 = this->ignoredProperties[_key401];
              xfer += iprot->readString(_val402);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.ignoredProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_storage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableSchema)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partitionColumns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_indexColumns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_primaryKeyColumns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_bucketOwners)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_bucketColumns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sortColumns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_owner)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_createTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_lastAccessTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_properties)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_unsupportedFeatures)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tracksPartitionsInCatalog)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schemaPreservesCase)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CatalogTableObject::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CatalogTableObject");

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.databaseName) {
    xfer += oprot->writeFieldBegin("databaseName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->databaseName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("tableType", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tableType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("storage", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->storage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableSchema", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->tableSchema);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.provider) {
    xfer += oprot->writeFieldBegin("provider", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->provider);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("partitionColumns", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partitionColumns.size()));
    std::vector<std::string> ::const_iterator _iter403;
    for (_iter403 = this->partitionColumns.begin(); _iter403 != this->partitionColumns.end(); ++_iter403)
    {
      xfer += oprot->writeString((*_iter403));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("indexColumns", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->indexColumns.size()));
    std::vector<std::string> ::const_iterator _iter404;
    for (_iter404 = this->indexColumns.begin(); _iter404 != this->indexColumns.end(); ++_iter404)
    {
      xfer += oprot->writeString((*_iter404));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("primaryKeyColumns", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->primaryKeyColumns.size()));
    std::vector<std::string> ::const_iterator _iter405;
    for (_iter405 = this->primaryKeyColumns.begin(); _iter405 != this->primaryKeyColumns.end(); ++_iter405)
    {
      xfer += oprot->writeString((*_iter405));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.numBuckets) {
    xfer += oprot->writeFieldBegin("numBuckets", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->numBuckets);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.redundancy) {
    xfer += oprot->writeFieldBegin("redundancy", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->redundancy);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("bucketOwners", ::apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->bucketOwners.size()));
    std::vector<BucketOwners> ::const_iterator _iter406;
    for (_iter406 = this->bucketOwners.begin(); _iter406 != this->bucketOwners.end(); ++_iter406)
    {
      xfer += (*_iter406).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bucketColumns", ::apache::thrift::protocol::T_LIST, 13);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->bucketColumns.size()));
    std::vector<std::string> ::const_iterator _iter407;
    for (_iter407 = this->bucketColumns.begin(); _iter407 != this->bucketColumns.end(); ++_iter407)
    {
      xfer += oprot->writeString((*_iter407));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sortColumns", ::apache::thrift::protocol::T_LIST, 14);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->sortColumns.size()));
    std::vector<std::string> ::const_iterator _iter408;
    for (_iter408 = this->sortColumns.begin(); _iter408 != this->sortColumns.end(); ++_iter408)
    {
      xfer += oprot->writeString((*_iter408));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRING, 15);
  xfer += oprot->writeString(this->owner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I64, 16);
  xfer += oprot->writeI64(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastAccessTime", ::apache::thrift::protocol::T_I64, 17);
  xfer += oprot->writeI64(this->lastAccessTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 18);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
    std::map<std::string, std::string> ::const_iterator _iter409;
    for (_iter409 = this->properties.begin(); _iter409 != this->properties.end(); ++_iter409)
    {
      xfer += oprot->writeString(_iter409->first);
      xfer += oprot->writeString(_iter409->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.stats) {
    xfer += oprot->writeFieldBegin("stats", ::apache::thrift::protocol::T_STRUCT, 19);
    xfer += this->stats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.viewOriginalText) {
    xfer += oprot->writeFieldBegin("viewOriginalText", ::apache::thrift::protocol::T_STRING, 20);
    xfer += oprot->writeString(this->viewOriginalText);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.viewText) {
    xfer += oprot->writeFieldBegin("viewText", ::apache::thrift::protocol::T_STRING, 21);
    xfer += oprot->writeString(this->viewText);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 22);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("unsupportedFeatures", ::apache::thrift::protocol::T_LIST, 23);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->unsupportedFeatures.size()));
    std::vector<std::string> ::const_iterator _iter410;
    for (_iter410 = this->unsupportedFeatures.begin(); _iter410 != this->unsupportedFeatures.end(); ++_iter410)
    {
      xfer += oprot->writeString((*_iter410));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tracksPartitionsInCatalog", ::apache::thrift::protocol::T_BOOL, 24);
  xfer += oprot->writeBool(this->tracksPartitionsInCatalog);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schemaPreservesCase", ::apache::thrift::protocol::T_BOOL, 25);
  xfer += oprot->writeBool(this->schemaPreservesCase);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ignoredProperties) {
    xfer += oprot->writeFieldBegin("ignoredProperties", ::apache::thrift::protocol::T_MAP, 26);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->ignoredProperties.size()));
      std::map<std::string, std::string> ::const_iterator _iter411;
      for (_iter411 = this->ignoredProperties.begin(); _iter411 != this->ignoredProperties.end(); ++_iter411)
      {
        xfer += oprot->writeString(_iter411->first);
        xfer += oprot->writeString(_iter411->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CatalogTableObject &a, CatalogTableObject &b) {
  using ::std::swap;
  swap(a.tableName, b.tableName);
  swap(a.databaseName, b.databaseName);
  swap(a.tableType, b.tableType);
  swap(a.storage, b.storage);
  swap(a.tableSchema, b.tableSchema);
  swap(a.provider, b.provider);
  swap(a.partitionColumns, b.partitionColumns);
  swap(a.indexColumns, b.indexColumns);
  swap(a.primaryKeyColumns, b.primaryKeyColumns);
  swap(a.numBuckets, b.numBuckets);
  swap(a.redundancy, b.redundancy);
  swap(a.bucketOwners, b.bucketOwners);
  swap(a.bucketColumns, b.bucketColumns);
  swap(a.sortColumns, b.sortColumns);
  swap(a.owner, b.owner);
  swap(a.createTime, b.createTime);
  swap(a.lastAccessTime, b.lastAccessTime);
  swap(a.properties, b.properties);
  swap(a.stats, b.stats);
  swap(a.viewOriginalText, b.viewOriginalText);
  swap(a.viewText, b.viewText);
  swap(a.comment, b.comment);
  swap(a.unsupportedFeatures, b.unsupportedFeatures);
  swap(a.tracksPartitionsInCatalog, b.tracksPartitionsInCatalog);
  swap(a.schemaPreservesCase, b.schemaPreservesCase);
  swap(a.ignoredProperties, b.ignoredProperties);
  swap(a.__isset, b.__isset);
}

CatalogTableObject::CatalogTableObject(const CatalogTableObject& other412) {
  tableName = other412.tableName;
  databaseName = other412.databaseName;
  tableType = other412.tableType;
  storage = other412.storage;
  tableSchema = other412.tableSchema;
  provider = other412.provider;
  partitionColumns = other412.partitionColumns;
  indexColumns = other412.indexColumns;
  primaryKeyColumns = other412.primaryKeyColumns;
  numBuckets = other412.numBuckets;
  redundancy = other412.redundancy;
  bucketOwners = other412.bucketOwners;
  bucketColumns = other412.bucketColumns;
  sortColumns = other412.sortColumns;
  owner = other412.owner;
  createTime = other412.createTime;
  lastAccessTime = other412.lastAccessTime;
  properties = other412.properties;
  stats = other412.stats;
  viewOriginalText = other412.viewOriginalText;
  viewText = other412.viewText;
  comment = other412.comment;
  unsupportedFeatures = other412.unsupportedFeatures;
  tracksPartitionsInCatalog = other412.tracksPartitionsInCatalog;
  schemaPreservesCase = other412.schemaPreservesCase;
  ignoredProperties = other412.ignoredProperties;
  __isset = other412.__isset;
}
CatalogTableObject::CatalogTableObject( CatalogTableObject&& other413) noexcept {
  tableName = std::move(other413.tableName);
  databaseName = std::move(other413.databaseName);
  tableType = std::move(other413.tableType);
  storage = std::move(other413.storage);
  tableSchema = std::move(other413.tableSchema);
  provider = std::move(other413.provider);
  partitionColumns = std::move(other413.partitionColumns);
  indexColumns = std::move(other413.indexColumns);
  primaryKeyColumns = std::move(other413.primaryKeyColumns);
  numBuckets = std::move(other413.numBuckets);
  redundancy = std::move(other413.redundancy);
  bucketOwners = std::move(other413.bucketOwners);
  bucketColumns = std::move(other413.bucketColumns);
  sortColumns = std::move(other413.sortColumns);
  owner = std::move(other413.owner);
  createTime = std::move(other413.createTime);
  lastAccessTime = std::move(other413.lastAccessTime);
  properties = std::move(other413.properties);
  stats = std::move(other413.stats);
  viewOriginalText = std::move(other413.viewOriginalText);
  viewText = std::move(other413.viewText);
  comment = std::move(other413.comment);
  unsupportedFeatures = std::move(other413.unsupportedFeatures);
  tracksPartitionsInCatalog = std::move(other413.tracksPartitionsInCatalog);
  schemaPreservesCase = std::move(other413.schemaPreservesCase);
  ignoredProperties = std::move(other413.ignoredProperties);
  __isset = std::move(other413.__isset);
}
CatalogTableObject& CatalogTableObject::operator=(const CatalogTableObject& other414) {
  tableName = other414.tableName;
  databaseName = other414.databaseName;
  tableType = other414.tableType;
  storage = other414.storage;
  tableSchema = other414.tableSchema;
  provider = other414.provider;
  partitionColumns = other414.partitionColumns;
  indexColumns = other414.indexColumns;
  primaryKeyColumns = other414.primaryKeyColumns;
  numBuckets = other414.numBuckets;
  redundancy = other414.redundancy;
  bucketOwners = other414.bucketOwners;
  bucketColumns = other414.bucketColumns;
  sortColumns = other414.sortColumns;
  owner = other414.owner;
  createTime = other414.createTime;
  lastAccessTime = other414.lastAccessTime;
  properties = other414.properties;
  stats = other414.stats;
  viewOriginalText = other414.viewOriginalText;
  viewText = other414.viewText;
  comment = other414.comment;
  unsupportedFeatures = other414.unsupportedFeatures;
  tracksPartitionsInCatalog = other414.tracksPartitionsInCatalog;
  schemaPreservesCase = other414.schemaPreservesCase;
  ignoredProperties = other414.ignoredProperties;
  __isset = other414.__isset;
  return *this;
}
CatalogTableObject& CatalogTableObject::operator=(CatalogTableObject&& other415) noexcept {
  tableName = std::move(other415.tableName);
  databaseName = std::move(other415.databaseName);
  tableType = std::move(other415.tableType);
  storage = std::move(other415.storage);
  tableSchema = std::move(other415.tableSchema);
  provider = std::move(other415.provider);
  partitionColumns = std::move(other415.partitionColumns);
  indexColumns = std::move(other415.indexColumns);
  primaryKeyColumns = std::move(other415.primaryKeyColumns);
  numBuckets = std::move(other415.numBuckets);
  redundancy = std::move(other415.redundancy);
  bucketOwners = std::move(other415.bucketOwners);
  bucketColumns = std::move(other415.bucketColumns);
  sortColumns = std::move(other415.sortColumns);
  owner = std::move(other415.owner);
  createTime = std::move(other415.createTime);
  lastAccessTime = std::move(other415.lastAccessTime);
  properties = std::move(other415.properties);
  stats = std::move(other415.stats);
  viewOriginalText = std::move(other415.viewOriginalText);
  viewText = std::move(other415.viewText);
  comment = std::move(other415.comment);
  unsupportedFeatures = std::move(other415.unsupportedFeatures);
  tracksPartitionsInCatalog = std::move(other415.tracksPartitionsInCatalog);
  schemaPreservesCase = std::move(other415.schemaPreservesCase);
  ignoredProperties = std::move(other415.ignoredProperties);
  __isset = std::move(other415.__isset);
  return *this;
}
void CatalogTableObject::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CatalogTableObject(";
  out << "tableName=" << to_string(tableName);
  out << ", " << "databaseName="; (__isset.databaseName ? (out << to_string(databaseName)) : (out << "<null>"));
  out << ", " << "tableType=" << to_string(tableType);
  out << ", " << "storage=" << to_string(storage);
  out << ", " << "tableSchema=" << to_string(tableSchema);
  out << ", " << "provider="; (__isset.provider ? (out << to_string(provider)) : (out << "<null>"));
  out << ", " << "partitionColumns=" << to_string(partitionColumns);
  out << ", " << "indexColumns=" << to_string(indexColumns);
  out << ", " << "primaryKeyColumns=" << to_string(primaryKeyColumns);
  out << ", " << "numBuckets="; (__isset.numBuckets ? (out << to_string(numBuckets)) : (out << "<null>"));
  out << ", " << "redundancy="; (__isset.redundancy ? (out << to_string(redundancy)) : (out << "<null>"));
  out << ", " << "bucketOwners=" << to_string(bucketOwners);
  out << ", " << "bucketColumns=" << to_string(bucketColumns);
  out << ", " << "sortColumns=" << to_string(sortColumns);
  out << ", " << "owner=" << to_string(owner);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "lastAccessTime=" << to_string(lastAccessTime);
  out << ", " << "properties=" << to_string(properties);
  out << ", " << "stats="; (__isset.stats ? (out << to_string(stats)) : (out << "<null>"));
  out << ", " << "viewOriginalText="; (__isset.viewOriginalText ? (out << to_string(viewOriginalText)) : (out << "<null>"));
  out << ", " << "viewText="; (__isset.viewText ? (out << to_string(viewText)) : (out << "<null>"));
  out << ", " << "comment="; (__isset.comment ? (out << to_string(comment)) : (out << "<null>"));
  out << ", " << "unsupportedFeatures=" << to_string(unsupportedFeatures);
  out << ", " << "tracksPartitionsInCatalog=" << to_string(tracksPartitionsInCatalog);
  out << ", " << "schemaPreservesCase=" << to_string(schemaPreservesCase);
  out << ", " << "ignoredProperties="; (__isset.ignoredProperties ? (out << to_string(ignoredProperties)) : (out << "<null>"));
  out << ")";
}

}}} // namespace
