/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#ifndef SNAPPYDATA_STRUCT_CATALOGTABLEOBJECT_H
#define SNAPPYDATA_STRUCT_CATALOGTABLEOBJECT_H


#include "snappydata_struct_Decimal.h"
#include "snappydata_struct_BlobChunk.h"
#include "snappydata_struct_ClobChunk.h"
#include "snappydata_struct_TransactionXid.h"
#include "snappydata_struct_ServiceMetaData.h"
#include "snappydata_struct_ServiceMetaDataArgs.h"
#include "snappydata_struct_OpenConnectionArgs.h"
#include "snappydata_struct_ConnectionProperties.h"
#include "snappydata_struct_HostAddress.h"
#include "snappydata_struct_SnappyExceptionData.h"
#include "snappydata_struct_StatementAttrs.h"
#include "snappydata_struct_ColumnValue.h"
#include "snappydata_struct_ColumnDescriptor.h"
#include "snappydata_struct_Row.h"
#include "snappydata_struct_OutputParameter.h"
#include "snappydata_struct_RowSet.h"
#include "snappydata_struct_PrepareResult.h"
#include "snappydata_struct_UpdateResult.h"
#include "snappydata_struct_StatementResult.h"
#include "snappydata_struct_BucketOwners.h"
#include "snappydata_struct_CatalogStorage.h"
#include "snappydata_struct_CatalogSchemaObject.h"
#include "snappydata_struct_CatalogStats.h"

#include "snappydata_types.h"

namespace io { namespace snappydata { namespace thrift {

typedef struct _CatalogTableObject__isset {
  _CatalogTableObject__isset() : databaseName(false), provider(false), numBuckets(false), redundancy(false), stats(false), viewOriginalText(false), viewText(false), comment(false), ignoredProperties(false) {}
  bool databaseName :1;
  bool provider :1;
  bool numBuckets :1;
  bool redundancy :1;
  bool stats :1;
  bool viewOriginalText :1;
  bool viewText :1;
  bool comment :1;
  bool ignoredProperties :1;
} _CatalogTableObject__isset;

class CatalogTableObject {
 public:

  CatalogTableObject(const CatalogTableObject&);
  CatalogTableObject(CatalogTableObject&&) noexcept;
  CatalogTableObject& operator=(const CatalogTableObject&);
  CatalogTableObject& operator=(CatalogTableObject&&) noexcept;
  CatalogTableObject() : tableName(), databaseName(), tableType(), tableSchema(), provider(), numBuckets(0), redundancy(0), owner(), createTime(0), lastAccessTime(0), viewOriginalText(), viewText(), comment(), tracksPartitionsInCatalog(0), schemaPreservesCase(0) {
  }

  virtual ~CatalogTableObject() noexcept;
  std::string tableName;
  std::string databaseName;
  std::string tableType;
  CatalogStorage storage;
  std::string tableSchema;
  std::string provider;
  std::vector<std::string>  partitionColumns;
  std::vector<std::string>  indexColumns;
  std::vector<std::string>  primaryKeyColumns;
  int32_t numBuckets;
  int32_t redundancy;
  std::vector<BucketOwners>  bucketOwners;
  std::vector<std::string>  bucketColumns;
  std::vector<std::string>  sortColumns;
  std::string owner;
  int64_t createTime;
  int64_t lastAccessTime;
  std::map<std::string, std::string>  properties;
  CatalogStats stats;
  std::string viewOriginalText;
  std::string viewText;
  std::string comment;
  std::vector<std::string>  unsupportedFeatures;
  bool tracksPartitionsInCatalog;
  bool schemaPreservesCase;
  std::map<std::string, std::string>  ignoredProperties;

  _CatalogTableObject__isset __isset;

  void __set_tableName(const std::string& val);

  void __set_databaseName(const std::string& val);

  void __set_tableType(const std::string& val);

  void __set_storage(const CatalogStorage& val);

  void __set_tableSchema(const std::string& val);

  void __set_provider(const std::string& val);

  void __set_partitionColumns(const std::vector<std::string> & val);

  void __set_indexColumns(const std::vector<std::string> & val);

  void __set_primaryKeyColumns(const std::vector<std::string> & val);

  void __set_numBuckets(const int32_t val);

  void __set_redundancy(const int32_t val);

  void __set_bucketOwners(const std::vector<BucketOwners> & val);

  void __set_bucketColumns(const std::vector<std::string> & val);

  void __set_sortColumns(const std::vector<std::string> & val);

  void __set_owner(const std::string& val);

  void __set_createTime(const int64_t val);

  void __set_lastAccessTime(const int64_t val);

  void __set_properties(const std::map<std::string, std::string> & val);

  void __set_stats(const CatalogStats& val);

  void __set_viewOriginalText(const std::string& val);

  void __set_viewText(const std::string& val);

  void __set_comment(const std::string& val);

  void __set_unsupportedFeatures(const std::vector<std::string> & val);

  void __set_tracksPartitionsInCatalog(const bool val);

  void __set_schemaPreservesCase(const bool val);

  void __set_ignoredProperties(const std::map<std::string, std::string> & val);

  bool operator == (const CatalogTableObject & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (__isset.databaseName != rhs.__isset.databaseName)
      return false;
    else if (__isset.databaseName && !(databaseName == rhs.databaseName))
      return false;
    if (!(tableType == rhs.tableType))
      return false;
    if (!(storage == rhs.storage))
      return false;
    if (!(tableSchema == rhs.tableSchema))
      return false;
    if (__isset.provider != rhs.__isset.provider)
      return false;
    else if (__isset.provider && !(provider == rhs.provider))
      return false;
    if (!(partitionColumns == rhs.partitionColumns))
      return false;
    if (!(indexColumns == rhs.indexColumns))
      return false;
    if (!(primaryKeyColumns == rhs.primaryKeyColumns))
      return false;
    if (__isset.numBuckets != rhs.__isset.numBuckets)
      return false;
    else if (__isset.numBuckets && !(numBuckets == rhs.numBuckets))
      return false;
    if (__isset.redundancy != rhs.__isset.redundancy)
      return false;
    else if (__isset.redundancy && !(redundancy == rhs.redundancy))
      return false;
    if (!(bucketOwners == rhs.bucketOwners))
      return false;
    if (!(bucketColumns == rhs.bucketColumns))
      return false;
    if (!(sortColumns == rhs.sortColumns))
      return false;
    if (!(owner == rhs.owner))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(lastAccessTime == rhs.lastAccessTime))
      return false;
    if (!(properties == rhs.properties))
      return false;
    if (__isset.stats != rhs.__isset.stats)
      return false;
    else if (__isset.stats && !(stats == rhs.stats))
      return false;
    if (__isset.viewOriginalText != rhs.__isset.viewOriginalText)
      return false;
    else if (__isset.viewOriginalText && !(viewOriginalText == rhs.viewOriginalText))
      return false;
    if (__isset.viewText != rhs.__isset.viewText)
      return false;
    else if (__isset.viewText && !(viewText == rhs.viewText))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    if (!(unsupportedFeatures == rhs.unsupportedFeatures))
      return false;
    if (!(tracksPartitionsInCatalog == rhs.tracksPartitionsInCatalog))
      return false;
    if (!(schemaPreservesCase == rhs.schemaPreservesCase))
      return false;
    if (__isset.ignoredProperties != rhs.__isset.ignoredProperties)
      return false;
    else if (__isset.ignoredProperties && !(ignoredProperties == rhs.ignoredProperties))
      return false;
    return true;
  }
  bool operator != (const CatalogTableObject &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CatalogTableObject & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CatalogTableObject &a, CatalogTableObject &b);

inline std::ostream& operator<<(std::ostream& out, const CatalogTableObject& obj)
{
  obj.printTo(out);
  return out;
}

}}} // namespace

#endif
